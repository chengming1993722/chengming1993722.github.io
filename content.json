{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Tomorrow","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-12-26T06:41:21.000Z","updated":"2018-12-26T06:41:21.168Z","comments":true,"path":"tags/index-1.html","permalink":"http://yoursite.com/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"——__new__和单例模式","slug":"——-new-和单例模式","date":"2019-04-19T01:35:48.000Z","updated":"2019-04-19T01:42:05.935Z","comments":true,"path":"2019/04/19/——-new-和单例模式/","link":"","permalink":"http://yoursite.com/2019/04/19/——-new-和单例模式/","excerpt":"","text":"new 与 init__new__ 方法属于新式类，即属于 object 类。它是一个静态方法，但是其第一个参数必须是一个类(cls)，这有点像一个 classmethod，其实将其看成是一个类方法也可以。该特殊方法被调用时，会创建类(cls)的一个新实例并返回，实例被创建后解释器会将该实例以及其它的参数传递给该实例的初始化函数 __init__，以对实例进行初始化 所以，__new__ 方法是一个类方法，用于创建一个实例，而 __init__ 方法是一个实例方法，用于初始化一个实例。 __new__ 方法在实例化一个类时被调用，重写该方法应该像如下的形式 class A(object): def __new__(cls, *args, **kwargs) return super(A, cls).__new__(cls, *args, **kwargs) new 实现单例模式class Singleton(object): def __new__(cls): if not hasattr(cls, &quot;_instance&quot;): cls._instance = super(Singleton, cls).__new__(cls) return cls._instance assert Singleton() is Singleton() 装饰器实现单例from functools import wraps def singleton(cls): instances = {} @wraps(cls) def getinstance(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return getinstance @singleton class MyClass(object): def __init__(self): pass","categories":[{"name":"单例模式","slug":"单例模式","permalink":"http://yoursite.com/categories/单例模式/"}],"tags":[]},{"title":"Flask学习整理","slug":"Flask学习整理","date":"2019-04-02T01:44:14.000Z","updated":"2019-04-02T03:05:10.559Z","comments":true,"path":"2019/04/02/Flask学习整理/","link":"","permalink":"http://yoursite.com/2019/04/02/Flask学习整理/","excerpt":"","text":"Flask 基础命令和环境配置 在项目目录下创建app文件夹并创建文件init.py mkdir app 在init.py中输入如下代码 from flask import Flask app = Flask(__name__) from app import routes 其一，这里有两个实体名为app。 app包由app目录和init.py脚本来定义构成，并在from app import routes语句中被引用。 app变量被定义为init.py脚本中的Flask类的一个实例，以至于它成为app包的属性。 其二，routes模块是在底部导入的，而不是在脚本的顶部。 最下面的导入是解决循环导入的问题，这是Flask应用程序的常见问题。 你将会看到routes模块需要导入在这个脚本中定义的app变量，因此将routes的导入放在底部可以避免由于这两个文件之间的相互引用而导致的错误。 在项目目录下创建一个文件，本次创建的是与项目目录同名的&lt;项目名&gt;.py,它仅拥有一个导入应用程序实例的行 from app import app 项目目录结构 microblog/ venv/ app/ __init__.py routes.py microblog.py FLASK_APP环境变量告诉Flask如何导入 export FLASK_APP=microblog.py export FLASK_ENV=development #设置开发环境 默认为生产环境product &apos;&apos;&apos;在windows 中设置将export改为set&apos;&apos;&apos; flask run # 运行程序 Flask插件 使用Flask-WTF插件来处理本应用中的Web表单，它对WTForms进行了浅层次的封装以便和Flask完美结合。这是本应用引入的第一个Flask插件，但绝不是最后一个。插件是Flask生态中的举足轻重的一部分，Flask故意设计为只包含核心功能以保持代码的整洁，并暴露接口以对接解决不同问题的插件 pip install flask-wtf Flask-Migrate。 这个插件是Alembic的一个Flask封装，是SQLAlchemy的一个数据库迁移框架。 使用数据库迁移增加了启动数据库时候的一些工作，但这对将来的数据库结构稳健变更来说，是一个很小的代价。 pip install flask-migrate 数据库配置 import os basedir = os.path.abspath(os.path.dirname(__file__)) class Config(object): # ... SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DATABASE_URL&apos;) or \\ &apos;sqlite:///&apos; + os.path.join(basedir, &apos;app.db&apos;) SQLALCHEMY_TRACK_MODIFICATIONS = False 创建数据库迁移存储库 运行flask db init来创建microblog的迁移存储库 flask db init flask db migrate子命令生成这些自动迁移 flask db migrate -m &quot;users table&quot; flask db migrate命令不会对数据库进行任何更改，只会生成迁移脚本。 要将更改应用到数据库，必须使用flask db upgrade命令 flask db upgrade flask db downgrade命令可以回滚上次的迁移 flask db downgrade Flask-Login。 该插件管理用户登录状态，以便用户可以登录到应用，然后用户在导航到该应用的其他页面时，应用会“记得”该用户已经登录。它还提供了“记住我”的功能，允许用户在关闭浏览器窗口后再次访问应用时保持登录状态 from flask_login import LoginManager app = Flask(__name__) # ... login = LoginManager(app) 四个属性 is_authenticated: 一个用来表示用户是否通过登录认证的属性，用True和False表示。 is_active: 如果用户账户是活跃的，那么这个属性是True，否则就是False（译者注：活跃用户的定义是该用户的登录状态是否通过用户名密码登录，通过“记住我”功能保持登录状态的用户是非活跃的）。 is_anonymous: 常规用户的该属性是False，对特定的匿名用户是True。 get_id(): 返回用户的唯一id的方法，返回值类型是字符串(Python 2下返回unicode字符串). Flask-Login提供了一个叫做UserMixin的mixin类来将四个属性归纳 # ... from flask_login import UserMixin class User(UserMixin, db.Model): # ... 用户加载函数 Flask项目conflg.py config.py参考链接 Flask form表单 form.validate_on_submit() form.validate_on_submit()就会获取到所有的数据，运行字段各自的验证器，全部通过之后就会返回True，这表示数据有效 表单参考链接 Flask url_for() 为了更好地管理这些链接，Flask提供了一个名为url_for()的函数，它使用URL到视图函数的内部映射关系来生成URL。 例如，url_for(‘login’)返回/login，url_for(‘index’)返回/index。 url_for()的参数是endpoint名称，也就是视图函数的名字 装饰器 @app.route(‘/login’, methods=[‘GET’, ‘POST’]) methods 列表 表示能接受处理的请求 数据库工具pip install flask-sqlalchemy Shell上下文 在microblog.py中实现一个函数，它通过添加数据库实例和模型来创建了一个shell上下文环境 from app import app, db from app.models import User, Post @app.shell_context_processor def make_shell_context(): return {&apos;db&apos;: db, &apos;User&apos;: User, &apos;Post&apos;: Post} (venv) $ flask shell &gt;&gt;&gt; db &lt;SQLAlchemy engine=sqlite:////Users/migu7781/Documents/dev/flask/microblog2/app.db&gt; &gt;&gt;&gt; User &lt;class &apos;app.models.User&apos;&gt; &gt;&gt;&gt; Post &lt;class &apos;app.models.Post&apos;&gt; Werkzeug 其中一个实现密码哈希的包是Werkzeug，当安装Flask时，你可能会在pip的输出中看到这个包，因为它是Flask的一个核心依赖项。 所以，Werkzeug已经安装在你的虚拟环境中。 以下Python shell会话演示了如何哈希密码 &gt;&gt;&gt; from werkzeug.security import generate_password_hash &gt;&gt;&gt; hash = generate_password_hash(&apos;foobar&apos;) &gt;&gt;&gt; hash &apos;pbkdf2:sha256:50000$vT9fkZM8$04dfa35c6476acf7e788a1b5b3c35e217c78dc04539d295f011f01f1 8cd2175f&apos;","categories":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/categories/Flask/"}],"tags":[{"name":"flask 基础操作","slug":"flask-基础操作","permalink":"http://yoursite.com/tags/flask-基础操作/"}]},{"title":"sqlalchemy 多个自引用和复合索引","slug":"sqlalchemy-多个自引用和复合索引","date":"2019-03-15T02:49:20.000Z","updated":"2019-03-15T07:53:11.656Z","comments":true,"path":"2019/03/15/sqlalchemy-多个自引用和复合索引/","link":"","permalink":"http://yoursite.com/2019/03/15/sqlalchemy-多个自引用和复合索引/","excerpt":"","text":"sqlalchemy 中的多个以引用关系class Page(Base): __tablename__ = &apos;pages&apos; id = Column(Integer, primary_key=True) title = Column(String(100), nullable=False) content = Column(Text, nullable=False) parent_id = Column(Integer, ForeignKey (&quot;pages.id&quot;), nullable=True) parent = relationship(&quot;Page&quot;, primaryjoin= (&apos;pages.c.id==pages.c.parent_id&apos;), remote_side=&apos;Page.id&apos;, backref=backref(&quot;children&quot; )) &apos;&apos;&apos;多个孩子指向父母； 子next_id 都是父id； 导入数据时孩子指向父母导入 &apos;&apos;&apos; next_id = Column(Integer, ForeignKey (&quot;pages.id&quot;), nullable=True) next = relationship(&quot;Page&quot;, primaryjoin= (&apos;pages.c.next_id==pages.c.id&apos;), remote_side=&apos;Page.id&apos;, backref=backref(&quot;prev&quot;, uselist=False)) uniqueconstraint 多列唯一uniqueconstraint（&apos;col1&apos;,&apos;col2&apos;）创建唯一组合索引","categories":[{"name":"SQLALchemy","slug":"SQLALchemy","permalink":"http://yoursite.com/categories/SQLALchemy/"}],"tags":[{"name":"表结构","slug":"表结构","permalink":"http://yoursite.com/tags/表结构/"}]},{"title":"reverseListNode","slug":"reverseListNode","date":"2019-02-28T03:24:54.000Z","updated":"2019-02-28T03:29:21.541Z","comments":true,"path":"2019/02/28/reverseListNode/","link":"","permalink":"http://yoursite.com/2019/02/28/reverseListNode/","excerpt":"","text":"ReverseListNodeclass ListNode: def __init__(self, x): self.val = x self.next = None def nodereverse(head): if head is None and head.next is None: return head pre = None while head: &apos;&apos;&apos;先用tmp保存head的下一个节点信息&apos;&apos;&apos; tmp = head.next &apos;&apos;&apos;让head指向pre&apos;&apos;&apos; head.next = pre pre = head head = tmp return pre head = ListNode(1); # 测试代码 p1 = ListNode(2); # 建立链表1-&gt;2-&gt;3-&gt;4-&gt;None; p2 = ListNode(3); p3 = ListNode(4); head.next = p1; p1.next = p2; p2.next = p3; p = nodereverse(head); # 输出链表 4-&gt;3-&gt;2-&gt;1-&gt;None print(p) while p: print(p.val) p = p.next","categories":[{"name":"ListNode","slug":"ListNode","permalink":"http://yoursite.com/categories/ListNode/"}],"tags":[{"name":"sort","slug":"sort","permalink":"http://yoursite.com/tags/sort/"}]},{"title":"SortSkill","slug":"SortSkill","date":"2019-02-21T07:55:25.000Z","updated":"2019-02-21T08:00:21.872Z","comments":true,"path":"2019/02/21/SortSkill/","link":"","permalink":"http://yoursite.com/2019/02/21/SortSkill/","excerpt":"","text":"排序大小写字母数字s = &quot;SortIng1234&quot; f1 = &quot;&quot;.join(sorted(s, key=lambda x: (x.isdigit(), x.isdigit() and int(x) % 2 == 0, x, x.isupper(), x.islower()),reverse=True)) print(f) s = &quot;SortIng1234&quot; m = &quot;&quot;.join(sorted(s, key=lambda x: (x, x.isdigit(), x.isdigit() and int(x) % 2 == 0, x.isupper(), x.islower()))) print(m) s = &quot;SortIng1234&quot; f2 = &quot;&quot;.join(sorted(s, key=lambda x: (x.isdigit(), x.isdigit() and int(x) % 2 == 0, x.isupper(), x.islower(), x))) print(f) a = &apos;1232312312340&apos; f3 = &quot;&quot;.join(sorted(a, key=lambda x: (x.isdigit() and int(x) % 2 == 0, x.isdigit(),))) print(f) a = &apos;1232312312340&apos; f4 = &quot;&quot;.join(sorted(a, key=lambda x: (x.isdigit() and int(x) % 2 == 0, x.isdigit(), x))) print(f)","categories":[],"tags":[]},{"title":"DataFrame数据统计","slug":"DataFrame数据统计","date":"2018-08-22T11:18:16.000Z","updated":"2018-12-26T06:40:58.648Z","comments":true,"path":"2018/08/22/DataFrame数据统计/","link":"","permalink":"http://yoursite.com/2018/08/22/DataFrame数据统计/","excerpt":"","text":"DataFrame 统计数据条目DataFrame.groupby(‘列名’).count()rtn.groupby(&apos;s_hw_everyday_level&apos;).count() # 统计各级‘s_hw_everyday_level’的个数 DataFrame[‘列名’].shapertn[&apos;s_hw_everyday_level].shape #返回DateFrame的列数 DataFrame[‘列名’]rtn[&apos;s_hw_everyday_level].count #返回&apos;s_hw_everyday_level&apos;的数量","categories":[{"name":"DataFrame","slug":"DataFrame","permalink":"http://yoursite.com/categories/DataFrame/"}],"tags":[{"name":"groupby,列操作","slug":"groupby-列操作","permalink":"http://yoursite.com/tags/groupby-列操作/"}]},{"title":"nametuple","slug":"nametuple","date":"2018-07-31T06:32:25.000Z","updated":"2018-08-01T01:47:15.989Z","comments":true,"path":"2018/07/31/nametuple/","link":"","permalink":"http://yoursite.com/2018/07/31/nametuple/","excerpt":"","text":"python3 nametuple使用namedtuple是继承自tuple的子类。namedtuple创建一个和tuple类似的对象，而且对象拥有可访问的属性collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None) 返回名为typename的新元组子类。新子类用于创建类似元组的对象，这些对象具有可通过属性查找访问的字段以及可索引和可​​迭代的字段。子类的实例还有一个有用的docstring（带有typename和field_names）和一个有用的repr （）方法，它以name = value格式列出元组内容 from collections import namedtuple #定义一个商品类型goods, 商品拥有name,number,price属性 Goods = namedtuple(&apos;Goods&apos;,[&apos;name&apos;,&apos;number&apos;,&apos;price&apos;]) #创建一个Goods对象 goods = Goods(name=&apos;apple&apos;,number=3,price=2.5) #也可以使用_make方法来创建一个Goods对象 goods = Goods._make([&apos;apple&apos;,3,2.5]) print(goods.number*goods.price) # result : 1 name,number,price=goods print(f&quot;{name}&apos;s price is {price}$ per kilogram,which has {number}kg,so tottal price is {number*price}$&quot;) _make(iterable)方法：用一个已存在的序列或可迭代的对象生成实例orange = [&apos;orange&apos;,&apos;2&apos;,&apos;4&apos;] goods = Goods._make(orange) print(goods) # result : Goods(name=&apos;orange&apos;, number=&apos;2&apos;, price=&apos;4&apos;) orange=(&apos;orange&apos;,&apos;2&apos;,&apos;4&apos;) goods = Goods._make(orange) print(goods) # result : Goods(name=&apos;orange&apos;, number=&apos;2&apos;, price=&apos;4&apos;) _asdict() : 返回一个OrderedDictorg = goods._asdict() #result : OrderedDict([(&apos;name&apos;, &apos;orange&apos;), (&apos;number&apos;, &apos;2&apos;), (&apos;price&apos;, &apos;4&apos;)]) _replace(*kwargs) : 替换指定属性的值goods._replace(name=&apos;juice&apos;) print(goods._replace(name=&apos;juice&apos;)) $ result : Goods(name=&apos;juice&apos;, number=&apos;2&apos;, price=&apos;4&apos;) _fields ： 返回一个包含Goods对象属性（’name’,’number’,’price’）的元组print(goods._fileds) #return : （&apos;name&apos;,&apos;number&apos;,&apos;price&apos;） _fields_defaults: 设置默认值***注：此方法为python3.7 新加的方法** &gt;&gt;&gt; Account = namedtuple(&apos;Account&apos;, [&apos;type&apos;, &apos;balance&apos;], defaults=[0]) &gt;&gt;&gt; Account._fields_defaults {&apos;balance&apos;: 0} &gt;&gt;&gt; Account(&apos;premium&apos;) Account(type=&apos;premium&apos;, balance=0) 一些用法&gt;&gt;&gt;getattr(goods, &apos;name&apos;) orange &gt;&gt;&gt;apple = {&apos;name&apos;:&apos;apple&apos;,&apos;number&apos;:3,&apos;price&apos;:5} &gt;&gt;&gt;goods = Goods(**apple) Goods(name=&apos;apple&apos;, number=3, price=5) &apos;&apos;&apos;&apos; 星号*把序列/集合解包（unpack）成位置参数，两个星号**把字典解包成关键字参数 &apos;&apos;&apos;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-07-27T06:56:23.728Z","updated":"2018-07-27T06:56:23.728Z","comments":true,"path":"2018/07/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}