{"title":"Flask学习整理","date":"2019-04-02T01:44:14.000Z","excerpt":"","slug":"Flask学习整理","tags":["flask 基础操作"],"categories":["Flask"],"updated":"2019-04-02T03:05:10.559Z","content":"<h2 id=\"Flask-基础命令和环境配置\"><a href=\"#Flask-基础命令和环境配置\" class=\"headerlink\" title=\"Flask 基础命令和环境配置\"></a>Flask 基础命令和环境配置</h2><ul>\n<li><p>在项目目录下创建app文件夹并创建文件<strong>init</strong>.py</p>\n<pre><code>mkdir app\n</code></pre></li>\n<li><p>在<strong>init</strong>.py中输入如下代码</p>\n<pre><code>from flask import Flask\n\napp = Flask(__name__)\n\nfrom app import routes\n</code></pre><ul>\n<li>其一，这里有两个实体名为app。 app包由app目录和<strong>init</strong>.py脚本来定义构成，并在from app import routes语句中被引用。 app变量被定义为<strong>init</strong>.py脚本中的Flask类的一个实例，以至于它成为app包的属性。</li>\n<li>其二，routes模块是在底部导入的，而不是在脚本的顶部。 最下面的导入是解决循环导入的问题，这是Flask应用程序的常见问题。 你将会看到routes模块需要导入在这个脚本中定义的app变量，因此将routes的导入放在底部可以避免由于这两个文件之间的相互引用而导致的错误。</li>\n</ul>\n</li>\n<li><p>在项目目录下创建一个文件，本次创建的是与项目目录同名的&lt;项目名&gt;.py,它仅拥有一个导入应用程序实例的行</p>\n<pre><code>from app import app\n</code></pre></li>\n<li><p>项目目录结构</p>\n<pre><code>microblog/\n    venv/\n    app/\n        __init__.py\n        routes.py\n     microblog.py\n</code></pre></li>\n<li><p>FLASK_APP环境变量告诉Flask如何导入</p>\n<pre><code>export FLASK_APP=microblog.py\nexport FLASK_ENV=development #设置开发环境 默认为生产环境product\n&apos;&apos;&apos;在windows 中设置将export改为set&apos;&apos;&apos;\nflask run # 运行程序\n</code></pre></li>\n</ul>\n<h2 id=\"Flask插件\"><a href=\"#Flask插件\" class=\"headerlink\" title=\"Flask插件\"></a>Flask插件</h2><ul>\n<li><p>使用Flask-WTF插件来处理本应用中的Web表单，它对WTForms进行了浅层次的封装以便和Flask完美结合。这是本应用引入的第一个Flask插件，但绝不是最后一个。插件是Flask生态中的举足轻重的一部分，Flask故意设计为只包含核心功能以保持代码的整洁，并暴露接口以对接解决不同问题的插件</p>\n<pre><code>pip install flask-wtf\n</code></pre></li>\n<li><p>Flask-Migrate。 这个插件是Alembic的一个Flask封装，是SQLAlchemy的一个数据库迁移框架。 使用数据库迁移增加了启动数据库时候的一些工作，但这对将来的数据库结构稳健变更来说，是一个很小的代价。</p>\n<pre><code>pip install flask-migrate\n</code></pre></li>\n<li><p>数据库配置 </p>\n<pre><code>import os\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\nclass Config(object):\n    # ...\n    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DATABASE_URL&apos;) or \\\n        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;app.db&apos;)\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n</code></pre></li>\n<li><p>创建数据库迁移存储库</p>\n<ul>\n<li><p>运行flask db init来创建microblog的迁移存储库</p>\n<pre><code>flask db init\n</code></pre></li>\n<li><p>flask db migrate子命令生成这些自动迁移</p>\n<pre><code>flask db migrate -m &quot;users table&quot;\n</code></pre></li>\n<li><p>flask db migrate命令不会对数据库进行任何更改，只会生成迁移脚本。 要将更改应用到数据库，必须使用flask db upgrade命令</p>\n<pre><code>flask db upgrade\n</code></pre></li>\n<li><p>flask db downgrade命令可以回滚上次的迁移</p>\n<pre><code>flask db downgrade\n</code></pre></li>\n</ul>\n</li>\n<li><p>Flask-Login。 该插件管理用户登录状态，以便用户可以登录到应用，然后用户在导航到该应用的其他页面时，应用会“记得”该用户已经登录。它还提供了“记住我”的功能，允许用户在关闭浏览器窗口后再次访问应用时保持登录状态</p>\n<pre><code>from flask_login import LoginManager\n\napp = Flask(__name__)\n# ...\nlogin = LoginManager(app)\n</code></pre><ul>\n<li><p>四个属性</p>\n<ul>\n<li>is_authenticated: 一个用来表示用户是否通过登录认证的属性，用True和False表示。</li>\n<li>is_active: 如果用户账户是活跃的，那么这个属性是True，否则就是False（译者注：活跃用户的定义是该用户的登录状态是否通过用户名密码登录，通过“记住我”功能保持登录状态的用户是非活跃的）。</li>\n<li>is_anonymous: 常规用户的该属性是False，对特定的匿名用户是True。</li>\n<li>get_id(): 返回用户的唯一id的方法，返回值类型是字符串(Python 2下返回unicode字符串).</li>\n</ul>\n</li>\n<li><p>Flask-Login提供了一个叫做UserMixin的mixin类来将四个属性归纳</p>\n<pre><code># ...\nfrom flask_login import UserMixin\n\nclass User(UserMixin, db.Model):\n    # ...\n</code></pre></li>\n<li><a href=\"https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.md\" target=\"_blank\" rel=\"noopener\">用户加载函数</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Flask项目conflg-py\"><a href=\"#Flask项目conflg-py\" class=\"headerlink\" title=\"Flask项目conflg.py\"></a>Flask项目conflg.py</h2><ul>\n<li><a href=\"https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AWeb%E8%A1%A8%E5%8D%95.md\" target=\"_blank\" rel=\"noopener\">config.py参考链接</a></li>\n</ul>\n<h2 id=\"Flask-form表单\"><a href=\"#Flask-form表单\" class=\"headerlink\" title=\"Flask form表单\"></a>Flask form表单</h2><ul>\n<li><p>form.validate_on_submit()</p>\n<ul>\n<li><p>form.validate_on_submit()就会获取到所有的数据，运行字段各自的验证器，全部通过之后就会返回True，这表示数据有效</p>\n</li>\n<li><p><a href=\"https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AWeb%E8%A1%A8%E5%8D%95.md\" target=\"_blank\" rel=\"noopener\">表单参考链接</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Flask-url-for\"><a href=\"#Flask-url-for\" class=\"headerlink\" title=\"Flask url_for()\"></a>Flask url_for()</h2><ul>\n<li>为了更好地管理这些链接，Flask提供了一个名为url_for()的函数，它使用URL到视图函数的内部映射关系来生成URL。 例如，url_for(‘login’)返回/login，url_for(‘index’)返回/index。 url_for()的参数是endpoint名称，也就是视图函数的名字</li>\n</ul>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><ul>\n<li><p>@app.route(‘/login’, methods=[‘GET’, ‘POST’])</p>\n<ul>\n<li>methods 列表 表示能接受处理的请求</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据库工具\"><a href=\"#数据库工具\" class=\"headerlink\" title=\"数据库工具\"></a>数据库工具</h2><pre><code>pip install flask-sqlalchemy\n</code></pre><h2 id=\"Shell上下文\"><a href=\"#Shell上下文\" class=\"headerlink\" title=\"Shell上下文\"></a>Shell上下文</h2><ul>\n<li><p>在microblog.py中实现一个函数，它通过添加数据库实例和模型来创建了一个shell上下文环境</p>\n<pre><code>from app import app, db\nfrom app.models import User, Post\n\n@app.shell_context_processor\ndef make_shell_context():\n    return {&apos;db&apos;: db, &apos;User&apos;: User, &apos;Post&apos;: Post}\n\n(venv) $ flask shell\n&gt;&gt;&gt; db\n&lt;SQLAlchemy engine=sqlite:////Users/migu7781/Documents/dev/flask/microblog2/app.db&gt;\n&gt;&gt;&gt; User\n&lt;class &apos;app.models.User&apos;&gt;\n&gt;&gt;&gt; Post\n&lt;class &apos;app.models.Post&apos;&gt;\n</code></pre></li>\n</ul>\n<h2 id=\"Werkzeug\"><a href=\"#Werkzeug\" class=\"headerlink\" title=\"Werkzeug\"></a>Werkzeug</h2><ul>\n<li><p>其中一个实现密码哈希的包是Werkzeug，当安装Flask时，你可能会在pip的输出中看到这个包，因为它是Flask的一个核心依赖项。 所以，Werkzeug已经安装在你的虚拟环境中。 以下Python shell会话演示了如何哈希密码</p>\n<pre><code>&gt;&gt;&gt; from werkzeug.security import generate_password_hash\n&gt;&gt;&gt; hash = generate_password_hash(&apos;foobar&apos;)\n&gt;&gt;&gt; hash\n&apos;pbkdf2:sha256:50000$vT9fkZM8$04dfa35c6476acf7e788a1b5b3c35e217c78dc04539d295f011f01f1      8cd2175f&apos;\n</code></pre></li>\n</ul>\n","next":{"title":"sqlalchemy 多个自引用和复合索引","slug":"sqlalchemy-多个自引用和复合索引"},"link":"/2019/04/02","toc":[{"title":"Flask 基础命令和环境配置","id":"Flask-基础命令和环境配置","index":"1"},{"title":"Flask插件","id":"Flask插件","index":"2"},{"title":"Flask项目conflg.py","id":"Flask项目conflg-py","index":"3"},{"title":"Flask form表单","id":"Flask-form表单","index":"4"},{"title":"Flask url_for()","id":"Flask-url-for","index":"5"},{"title":"装饰器","id":"装饰器","index":"6"},{"title":"数据库工具","id":"数据库工具","index":"7"},{"title":"Shell上下文","id":"Shell上下文","index":"8"},{"title":"Werkzeug","id":"Werkzeug","index":"9"}]}