{"title":"——__new__和单例模式","date":"2019-04-19T01:35:48.000Z","excerpt":"","slug":"——-new-和单例模式","categories":["单例模式"],"updated":"2019-04-19T01:42:05.935Z","content":"<h2 id=\"new-与-init\"><a href=\"#new-与-init\" class=\"headerlink\" title=\"new 与 init\"></a>new 与 init</h2><pre><code>__new__ 方法属于新式类，即属于 object 类。它是一个静态方法，但是其第一个参数必须是一个类(cls)，这有点像一个 classmethod，其实将其看成是一个类方法也可以。该特殊方法被调用时，会创建类(cls)的一个新实例并返回，实例被创建后解释器会将该实例以及其它的参数传递给该实例的初始化函数 __init__，以对实例进行初始化\n\n所以，__new__ 方法是一个类方法，用于创建一个实例，而 __init__ 方法是一个实例方法，用于初始化一个实例。\n\n__new__ 方法在实例化一个类时被调用，重写该方法应该像如下的形式\n\nclass A(object):\n    def __new__(cls, *args, **kwargs)\n    return super(A, cls).__new__(cls, *args, **kwargs)\n</code></pre><h2 id=\"new-实现单例模式\"><a href=\"#new-实现单例模式\" class=\"headerlink\" title=\"new 实现单例模式\"></a><strong>new</strong> 实现单例模式</h2><pre><code>class Singleton(object):\n    def __new__(cls):\n        if not hasattr(cls, &quot;_instance&quot;):\n            cls._instance = super(Singleton, cls).__new__(cls)\n        return cls._instance\n\nassert Singleton() is Singleton()\n</code></pre><h2 id=\"装饰器实现单例\"><a href=\"#装饰器实现单例\" class=\"headerlink\" title=\"装饰器实现单例\"></a>装饰器实现单例</h2><pre><code>from functools import wraps\n\ndef singleton(cls):\n    instances = {}\n    @wraps(cls)\n    def getinstance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return getinstance\n\n@singleton\nclass MyClass(object):\n\n    def __init__(self):\n        pass\n</code></pre>","next":{"title":"Flask学习整理","slug":"Flask学习整理"},"link":"/2019/04/19","toc":[{"title":"new 与 init","id":"new-与-init","index":"1"},{"title":"<strong>new</strong> 实现单例模式","id":"new-实现单例模式","index":"2"},{"title":"装饰器实现单例","id":"装饰器实现单例","index":"3"}]}